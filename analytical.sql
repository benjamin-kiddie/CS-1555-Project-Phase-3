------------------------------------------------
-- CS1555/2055 Project 2 Analytical Queries
-- Implements all assigned analytical queries.
--
-- Authors: Hala Nubani, Ethan Wells, Ben Kiddie
------------------------------------------------

SET SCHEMA 'arbor_db';

-- View that shows the number of sensors in a forest.
-- Used by rankForestSensors().
DROP VIEW IF EXISTS numSensorsInForest;
CREATE VIEW numSensorsInForest AS
    SELECT i.forest_no, COUNT(forest_no) AS num_sensors
    FROM (SELECT forest_no, sensor_id
          FROM SENSOR s
          JOIN FOREST f ON (s.x BETWEEN f.mbr_xmin AND f.mbr_xmax)
                            AND (s.y BETWEEN f.mbr_ymin AND f.mbr_ymax)) AS i
    GROUP BY i.forest_no;

-- Rank all forests based on the number of sensors within them,
-- with forests with more sensors being ranked higher than
-- forests with fewer sensors.
CREATE OR REPLACE FUNCTION rankForestSensors() RETURNS TABLE (
        forest_no integer,
        rank bigint
    ) AS
    $$
    BEGIN
        RETURN QUERY
        SELECT n.forest_no, RANK () OVER (
            ORDER BY n.num_sensors DESC
        )
        FROM numSensorsInForest n;
    END;
    $$ LANGUAGE plpgsql;

-- List all forests that are habitable for a given tree species
-- based on temperature data from the past k years.
CREATE OR REPLACE FUNCTION habitableEnvironment(g varchar(30), e varchar(30),
                                                k integer) RETURNS TABLE (
        forest_no integer,
        name varchar(30),
        area integer,
        acid_level real,
        MBR_XMin real,
        MBR_XMax real,
        MBR_YMin real,
        MBR_YMax real
    ) AS
    $$
    DECLARE
        synth_time timestamp;
        ideal_temp real;
        upper_temp real;
        lower_temp real;
        start_date timestamp;
    BEGIN
        -- Find ideal temperature for given species.
        SELECT ideal_temperature
        INTO ideal_temp
        FROM TREE_SPECIES WHERE genus = g AND EPITHET = e;
        -- Calculate appropriate upper and lower bound temperatures.
        upper_temp := ideal_temp + 5;
        lower_temp := ideal_temp - 5;
        -- Fetch current synthetic time.
        SELECT INTO synth_time * FROM CLOCK;
        -- Find start date for average temperatures.
        SELECT synth_time - (INTERVAL '1 year' * k) INTO start_date;
        -- Find suitable forests with the ugliest query yet created by man.
        RETURN QUERY
        SELECT p.forest_no, f.name, f.area, f.acid_level, f.mbr_xmin, f.mbr_xmax, f.mbr_ymin, f.mbr_ymax
        FROM (SELECT srf.forest_no, AVG(srf.temperature) AS average_temperature -- calculate average temperature
              FROM (SELECT f.forest_no, sr.temperature
                    FROM (SELECT s.x, s.y, r.temperature
                          FROM SENSOR s
                          NATURAL JOIN (SELECT * FROM REPORT -- find temperatures for sensors
                                        WHERE report_time BETWEEN start_date AND
                                            synth_time) AS r) AS sr
                    JOIN FOREST f ON (sr.x BETWEEN f.mbr_xmin AND f.mbr_xmax) -- find forests for sensors
                                      AND (sr.y BETWEEN f.mbr_ymin AND f.mbr_ymax)) AS srf
              GROUP BY srf.forest_no) AS p
        NATURAL JOIN FOREST as f -- to get full forest tuple
        WHERE average_temperature BETWEEN lower_temp AND upper_temp; -- filter by appropriate avg temp
    END;
    $$ LANGUAGE plpgsql;

-- Display top k sensors with respect to the number of reports
-- generated by the sensor int he past x months (args 1 and 2)
CREATE OR REPLACE FUNCTION topSensors(num_sensors integer, months integer) RETURNS TABLE (
        sensor_id integer,
        last_charged timestamp,
        energy integer,
        last_read timestamp,
        X real,
        Y real,
        maintainer_id varchar(9),
        num_reports bigint
    ) AS $$
    DECLARE
        days_int interval; -- Days before synthetic time
        synth_time timestamp; -- Synthetic clock time
        base_time timestamp; -- Time after interval subtraction
    BEGIN
        -- Acquire time from synthetic clock
        SELECT synthetic_time INTO synth_time FROM CLOCK;
        -- Subtract number of months (as days) from synthetic time value (implicit cast)
        days_int = (months * 30) || ' days';
        base_time = synth_time - days_int;
        -- Return full sensor tuple + number of reports generated in past 'months' months (see next line)
        RETURN QUERY
        SELECT rn.sensor_id, rn.last_charged, rn.energy, rn.last_read, rn.X, rn.Y, rn.maintainer_id, rn.num_reports
        FROM ((SELECT r.sensor_id, COUNT(r.sensor_id) AS num_reports -- Get table of reports per sensor_id
               FROM REPORT r
               WHERE r.report_time >= base_time AND r.report_time <= synth_time
               GROUP BY r.sensor_id) AS i
               NATURAL JOIN SENSOR) AS rn -- Natural join to get full sensor tuples
        WHERE rn.num_reports IS NOT NULL
        ORDER BY rn.num_reports DESC
        LIMIT num_sensors;
    END;
    $$ LANGUAGE plpgsql;


-- View that pairs all forests that share a tree species.
-- Used by threeDegrees().
DROP VIEW IF EXISTS sharesSpecies;
CREATE VIEW sharesSpecies AS
    SELECT f1.forest_no AS for_1, f2.forest_no AS for_2
    FROM FOUND_IN f1
    JOIN FOUND_IN f2 ON f1.genus = f2.genus AND f1.epithet = f2.epithet
                        AND f1.forest_no != f2.forest_no;

-- Find a path with at most 3 hops between two forests. where a hop is wo forests having the same tree species
CREATE OR REPLACE FUNCTION threeDegrees(f1 integer, f2 integer) RETURNS TABLE (
    path text
  ) AS
    $$
    DECLARE
        p varchar(35);
    BEGIN
        RETURN QUERY
        WITH RECURSIVE ForestPath AS (
            SELECT s.for_1, s.for_2, 1 as num_hops, s.for_1 || ' -> ' || s.for_2 AS path
            FROM sharesSpecies s
            WHERE s.for_1 = f1
            UNION
                SELECT p.for_1, s.for_2, p.num_hops + 1, p.path || ' -> ' || s.for_2
                FROM ForestPath p, SharesSpecies s
                WHERE p.for_2 = s.for_1 AND p.num_hops < 3
        )
        SELECT p.path
        FROM ForestPath p
        WHERE for_2 = f2
        ORDER BY CHAR_LENGTH(p.path)
        LIMIT 1;
    END;
    $$ LANGUAGE plpgsql;
